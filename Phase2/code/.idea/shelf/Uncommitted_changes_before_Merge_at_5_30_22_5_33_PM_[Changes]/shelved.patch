Index: memory.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#At time x allocated y bytes for process z from i to j\nAt time 0 allocated 236 bytes for process 1 from 0 to 255\nAt time 1 freed 236 bytes for process 1 from 0 to 255\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/memory.log b/memory.log
--- a/memory.log	(revision 7e111f33249e37bbf75b675b4b7643642ec3e4d5)
+++ b/memory.log	(date 1653924763110)
@@ -1,3 +1,7 @@
 #At time x allocated y bytes for process z from i to j
-At time 0 allocated 236 bytes for process 1 from 0 to 255
-At time 1 freed 236 bytes for process 1 from 0 to 255
+At time 10 allocated 152 bytes for process 1 from 0 to 255
+At time 12 freed 152 bytes for process 1 from 0 to 255
+At time 13 allocated 66 bytes for process 3 from 0 to 127
+At time 32 freed 66 bytes for process 3 from 0 to 127
+At time 32 allocated 253 bytes for process 4 from 0 to 255
+At time 53 freed 253 bytes for process 4 from 0 to 255
Index: scheduler.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#At time x process y state arr w total z remain y wait k\nAt time 0 process 1 started arr 0 total 1 remain 1 wait 0\nAt time 1 process 1 finished arr 0 total 1 remain 0 wait 0 TA 1 WTA 1.00\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.log b/scheduler.log
--- a/scheduler.log	(revision 7e111f33249e37bbf75b675b4b7643642ec3e4d5)
+++ b/scheduler.log	(date 1653924763110)
@@ -1,3 +1,7 @@
 #At time x process y state arr w total z remain y wait k
-At time 0 process 1 started arr 0 total 1 remain 1 wait 0
-At time 1 process 1 finished arr 0 total 1 remain 0 wait 0 TA 1 WTA 1.00
+At time 10 process 1 started arr 10 total 2 remain 2 wait 0
+At time 12 process 1 finished arr 10 total 2 remain 0 wait 0 TA 2 WTA 1.00
+At time 13 process 3 started arr 13 total 19 remain 19 wait 0
+At time 32 process 3 finished arr 13 total 19 remain 0 wait 0 TA 19 WTA 1.00
+At time 32 process 4 started arr 14 total 21 remain 21 wait 18
+At time 53 process 4 finished arr 14 total 21 remain 0 wait 18 TA 39 WTA 1.86
Index: scheduler.perf
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>CPU utilization = 50.00 %\nAvg WTA = 1.00\nAvg Waiting = 0.00\nStd WTA = 0.00\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.perf b/scheduler.perf
--- a/scheduler.perf	(revision 7e111f33249e37bbf75b675b4b7643642ec3e4d5)
+++ b/scheduler.perf	(date 1653924763110)
@@ -1,4 +1,4 @@
-CPU utilization = 50.00 %
+CPU utilization = 79.25 %
 Avg WTA = 1.00
-Avg Waiting = 0.00
+Avg Waiting = 6.00
 Std WTA = 0.00
Index: scheduler.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"headers.h\"\n#include \"hashmap.h\"\n#include \"circular_queue.h\"\n#include \"priority_queue.h\"\n#include \"math.h\"\n#include \"queue.h\"\n#include \"buddy_core.c\"\n\n#define pcb_s struct PCB\ntypedef struct PCB {\n    int id; // this is the key in the hashmap\n    int pid;\n    int arrival_time;\n    int priority;\n    short state;\n    int cum_runtime;\n    int burst_time;\n    int remaining_time;\n    int waiting_time;\n    //...............................P2\n    int mem_size;\n    int memory_start_ind;\n    int memory_end_ind;\n} PCB;\n\n\nFILE *sch_log, *sch_perf, *mem_log;\nint TotalWaitingTime = 0;\nint TotalWTA = 0;\nint TotalRunTime = 0;\nint TotalNumberOfProcesses = 0;\nint *WeightedTA = NULL;\nint WTAIterator = 0;\n\nvoid OutputFinishedProcesses(int CurrTime, PCB *current_pcb, int TA, float WTA);\n\nvoid print(int CurrentTime, PCB *current, pair_t *Index, char type);\n\nvoid scheduler_log();\n\nvoid memory_log();\n\nfloat CalcStdWTA(float AvgWTA);\n\nvoid scheduler_perf(int ProcessCount);\n\nvoid FinishPrinting();\n\nint RR2(int quantum);\n\nint SRTN();\n\nint HPF();\n\n// 3 functions related to the hashmap\nint process_compare(const void *a, const void *b, void *udata) {\n    const struct PCB *process_a = a;\n    const struct PCB *process_b = b;\n    return (process_a->id - process_b->id);\n}\n\nbool process_iter(const void *item, void *udata) {\n    const struct PCB *process = item;\n    printf(\"process: (id=%d) (arrivalTime=%d) (runTime=%d) (priority=%d) (pid=%d) (state=%d) (remainingTime=%d) (mem_size=%d) (memory_start=%d) (memory_end_ind=%d)\\n\",\n           process->pid, process->arrival_time, process->cum_runtime, process->priority, process->pid, process->state,\n           process->remaining_time, process->mem_size, process->memory_start_ind, process->memory_end_ind);\n    return true;\n}\n\nuint64_t process_hash(const void *item, uint64_t seed0, uint64_t seed1) {\n    const struct PCB *process = item;\n    return hashmap_sip(&process->id, sizeof(process->id), seed0, seed1);\n}\n\n// TODO init this in the main of the scheduler\nstruct hashmap *process_table;\nint process_msg_queue;\n\n// when process generator tells us that there is no more to come\n// set this to false\n\nbool more_processes_coming = true;\n\nvoid set_no_more_processes_coming(int signum) {\n    more_processes_coming = false;\n}\n\nint main(int argc, char *argv[]) {\n    // process Gen sends a SIGUSR1 to sch to tell than no more processes are coming\n    signal(SIGUSR1, set_no_more_processes_coming);\n\n    // create and open files\n    scheduler_log();\n    memory_log();\n    initClk();\n    buddy_init();\n\n    int remain_time_shmid = shmget(REMAIN_TIME_SHMKEY, 4, IPC_CREAT | 0644);\n    if (remain_time_shmid == -1)\n        perror(\"cant init remaining time shm: \\n\");\n    shm_remain_time = (int *) shmat(remain_time_shmid, NULL, 0);\n    *shm_remain_time = -1;\n\n    process_table = hashmap_new(sizeof(PCB), 0, 0, 0, process_hash, process_compare, NULL);\n\n    struct chosen_algorithm coming;\n    int key_id = ftok(\"keyfile\", 'q');\n    process_msg_queue = msgget(key_id, 0666 | IPC_CREAT);\n    msgrcv(process_msg_queue, &coming, sizeof(coming) - sizeof(coming.mtype), ALGO_TYPE, !IPC_NOWAIT);\n\n    // Set number of processes to use in statistics (scheduler.perf)\n    TotalNumberOfProcesses = coming.NumOfProcesses;\n    WeightedTA = (int *) malloc(sizeof(int) * TotalNumberOfProcesses);\n\n    printf(\"\\nchosen Algo is %d\\n\", coming.algo);\n\n    switch (coming.algo) {\n        case 1:\n            printf(\"RR with q=%d at time: %d\\n\", coming.arg, getClk());\n            RR2(coming.arg);\n            break;\n\n        case 2:\n            printf(\"HPF\\n\");\n            HPF();\n            break;\n        case 3:\n            printf(\"SRTN\\n\");\n            SRTN();\n            break;\n    }\n    printf(\"DONE scheduler\\n\");\n    scheduler_perf(TotalNumberOfProcesses);\n    FinishPrinting();\n    // upon termination release the clock resources.\n    hashmap_free(process_table);\n    shmctl(remain_time_shmid, IPC_RMID, NULL);\n    destroyClk(true);\n}\n\nPCB set_process(process_struct coming_process ){\n     struct PCB pcb;\n            pcb.id = coming_process.id;\n            pcb.pid = 0;\n            pcb.priority = coming_process.priority;\n            pcb.arrival_time = coming_process.arrival;\n            pcb.cum_runtime = 0;\n            pcb.remaining_time = coming_process.runtime; // at the beginning\n            pcb.burst_time = coming_process.runtime;     // at the beginning\n            pcb.mem_size = coming_process.memsize;\n            pcb.waiting_time = 0;\n\n\n            return pcb;\n\n}\nint RR2(int quantum)\n{\n    /**\n     * i loop all the time\n     * till a variable tells me that there is no more processes coming\n     * this is when i quit\n     * All the processes that in the circular queue are in the process_table\n     * when finished -> u delete from both\n     **/\n    struct c_queue RRqueue;\n    circular_init_queue(&RRqueue);\n\n    queue waiting_queue = initQueue(); // to receive in it\n\n    PCB *current_pcb;\n    int curr_q_start;\n    int p_count = TotalNumberOfProcesses;\n    int need_to_receive = TotalNumberOfProcesses;\n    bool process_is_currently_running = false;\n    int curr = 0;\n    while (!circular_is_empty(&RRqueue) || p_count > 0) {\n        printf(\"\\n in loop \\n\");\n        // First check if any process has come\n        struct count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        int num_messages = c.count;\n        need_to_receive -= c.count;\n        curr = getClk();\n\n        while (num_messages > 0) {\n            // while still a process in the queue\n            // take it out\n            // add it to both the RRqueue and its PCB to the processTable\n            process_struct coming_process;\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 1,\n                   !IPC_NOWAIT);\n            printf(\"\\nrecv process with id: %d at time %d\\n\", coming_process.id, getClk());\n            //  you have that struct Now\n            PCB pcb= set_process(coming_process);\n\n            pushQueue(&waiting_queue, coming_process.id); // add to the waiting list and will see if you can Run\n            hashmap_set(process_table, &pcb); // this copies the content of the struct\n            num_messages--;\n\n\n        }\n\n        //  printf(\"curr is %d: %d\\n\", getClk(), more_processes_coming);\n        // if its time ended or its quantum -> switch (Advance front)\n        // otherwise just let it run in peace\n        // if there is a running process -> see if it can be finished or not\n\n//        hashmap_scan(process_table, process_iter, NULL);\n        if (!isEmptyQueue(&waiting_queue)) {\n            int n_loops = waiting_queue.size;\n            while (n_loops--) {\n                int id = front(&waiting_queue);\n                popQueue(&waiting_queue);\n                PCB *_pcb = hashmap_get(process_table, &(PCB) {.id = id});\n                pair_t ret;\n\n                if (buddy_allocate(_pcb->mem_size, &ret)) {\n                    _pcb->state = READY; // allocated and in ready Queue\n                    _pcb->memory_start_ind = ret.start_ind;\n                    _pcb->memory_end_ind = ret.end_ind;\n                    circular_enQueue(&RRqueue, id);\n                    print(curr, _pcb, &ret, 'a');\n\n                } else {\n                    pushQueue(&waiting_queue, id);\n                }\n            }\n        }\n\n\n        if (process_is_currently_running) {\n            current_pcb = hashmap_get(process_table, &(PCB) {.id = RRqueue.front->data});\n\n            if (curr - curr_q_start >= current_pcb->remaining_time) { // that process will be finished\n                int st;\n\n                current_pcb->remaining_time = 0;\n                current_pcb->cum_runtime = current_pcb->burst_time;\n                int ret = wait(&st);\n                if (ret == -1) {\n                    perror(\"error in waiting the Process:\");\n                }\n                // if a process ended normally -- you're sure that the signal came from a dead process -- not stopped or resumed\n                int TA = curr - current_pcb->arrival_time;\n                current_pcb->waiting_time = TA - current_pcb->burst_time;\n                float WTA = (float) TA / current_pcb->burst_time;\n\n                OutputFinishedProcesses(curr, current_pcb, TA, WTA);\n                p_count--;\n                circular_deQueue(&RRqueue); // auto advance the queue\n                buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                print(curr, current_pcb, NULL, 'd');\n\n                hashmap_delete(process_table, current_pcb);\n                process_is_currently_running = false;\n\n                // if its multiple of q finished and there are some other in the Q waiting\n            } else if ((curr - curr_q_start) && (curr - curr_q_start) % quantum == 0 &&\n                       !circular_is_empty_or_one_left(&RRqueue)) {\n\n                current_pcb->remaining_time -= curr - curr_q_start;\n                kill(current_pcb->pid, SIGSTOP);\n                current_pcb->cum_runtime += curr - curr_q_start;\n                current_pcb->waiting_time = curr - current_pcb->arrival_time - current_pcb->cum_runtime;\n                print(curr, current_pcb, NULL, 'p');\n                current_pcb->state = READY; // back to Ready state\n                circular_advance_queue(&RRqueue);\n                process_is_currently_running = false;\n            }\n        }\n\n\n        if (!process_is_currently_running && !circular_is_empty(&RRqueue)) {\n            // update the current_pcb as the queue is advanced\n            current_pcb = hashmap_get(process_table, &(PCB) {.id = RRqueue.front->data});\n            if (current_pcb->pid == 0) { // if current process never started before\n                *shm_remain_time = current_pcb->remaining_time;\n                int pid = fork();\n                if (pid == 0) {\n                    // child\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n\n                // parent\n                current_pcb->pid = pid; // update Pid of existing process\n\n                current_pcb->waiting_time = curr - current_pcb->arrival_time;\n                print(curr, current_pcb, NULL, 's');\n\n\n            } else {\n\n                kill(current_pcb->pid, SIGCONT);\n                current_pcb->waiting_time = curr - current_pcb->arrival_time - current_pcb->cum_runtime;\n                *shm_remain_time = current_pcb->remaining_time;\n                print(curr, current_pcb, NULL, 'r');\n            }\n            current_pcb->state = RUNNING;\n            process_is_currently_running = true;\n            curr_q_start = curr; // started a quantum\n        }\n\n        // if the current's quantum finished and only one left -> no switch\n        // if the current terminated and no other in the Queue -> no switching\n    }\n    printf(\"\\nOut at time %d\\n\", curr);\n    return curr;\n}\n\n\n//----------------------------------------------------------------\nint SRTN() {\n    printf(\"Entering SRTN \\n\");\n    // intialize the priority queue\n    minHeap sQueue;\n    sQueue = init_min_heap();\n\n    minHeap waiting_queue;\n    waiting_queue = init_min_heap();\n    PCB *current_pcb = NULL;\n    int p_count = TotalNumberOfProcesses;\n    int need_to_receive = TotalNumberOfProcesses;\n    bool process_is_currently_running = false;\n    bool can_insert = true;\n    int current_time = 0;\n\n        // if the Queue is empty then check if there is no more processes that will come\n        // the main loop for the scheduler\n        while (!is_empty(&sQueue) || p_count > 0)\n    {\n        // First check if any process has come\n        count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        current_time = getClk();\n        int num_messages = c.count;\n        need_to_receive -= c.count;\n        while (num_messages > 0) {\n            // while still a process in the queue\n            // take it out\n            // add it to both the Prority Queue (sQueue) and its PCB to the processTable\n            process_struct coming_process;\n\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 1,\n                   !IPC_NOWAIT);\n            printf(\"\\nrecv process with id: %d at time %d with priority %d\\n\", coming_process.id, current_time,\n                   coming_process.priority);\n\n            //  you have that struct Now\n            PCB pcb= set_process(coming_process);\n            // pcb.id = coming_process.id;\n            // pcb.pid = 0;\n            // // pcb.arrival_time = coming_process.arrival;\n            // pcb.arrival_time = current_time;\n            // pcb.priority = coming_process.priority;\n            // pcb.state = READY;\n            // pcb.cum_runtime = 0;\n            // pcb.burst_time = coming_process.runtime;     // at the beginning\n            // pcb.remaining_time = coming_process.runtime; // at the beginning\n            // pcb.waiting_time = 0;\n            // pcb.mem_size = coming_process.memsize;                           // at the beginning\n            hashmap_set(process_table, &pcb);             // this copies the content of the struct\n            push(&waiting_queue, pcb.remaining_time, pcb.id); // add this process to the end of the Queue\n            num_messages--;\n        }\n\n        if (current_pcb != NULL)\n        {\n            current_pcb->remaining_time -= (current_time - (current_pcb->arrival_time + current_pcb->cum_runtime + current_pcb->waiting_time));\n            current_pcb->cum_runtime = current_pcb->burst_time - current_pcb->remaining_time;\n            if (current_pcb->remaining_time <= 0)\n            {\n                current_pcb->remaining_time = 0;\n                current_pcb->cum_runtime = current_pcb->burst_time;\n                // kill and out new data\n                int dum;\n                int ret = wait(&dum);\n                int TA = current_time - current_pcb->arrival_time;\n\n                float WTA = (float) TA / current_pcb->burst_time;\n\n                OutputFinishedProcesses(current_time, current_pcb, TA, WTA);\n                print(current_time, current_pcb, NULL, 'd');\n\n\n                buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                hashmap_delete(process_table, current_pcb);\n                p_count--;\n                current_pcb = NULL;\n            }\n        }\n        minHeap tempQueue;\n        tempQueue = init_min_heap();\n        if (!is_empty(&waiting_queue))\n        {\n            while (!is_empty(&waiting_queue))\n            {\n                node *temp = pop(&waiting_queue);\n                PCB *_pcb = hashmap_get(process_table, &(PCB){.id = temp->data});\n                pair_t ret;\n                //printf(\"mem size %d\\n\",_pcb->mem_size);\n                can_insert = buddy_allocate(_pcb->mem_size, &ret);\n                if (can_insert)\n                {\n                    _pcb->state = READY; // allocated and in ready Queue\n                    _pcb->memory_start_ind = ret.start_ind;\n                    _pcb->memory_end_ind = ret.end_ind;\n                    push(&sQueue, _pcb->remaining_time, _pcb->id); // add this process to the end of the Queue\n                    print(current_time, _pcb, &ret, 'a');\n                }\n                else\n                {\n                    push(&tempQueue, _pcb->remaining_time, _pcb->id);\n                }\n            }\n        }\n        while (!is_empty(&tempQueue))\n        {\n            node *temp = pop(&tempQueue);\n            push(&waiting_queue, temp->priority, temp->data);\n        }\n        // 3 cases\n        // first is first start process or there is gap between processes -> Done\n        // second update the remaining time\n        // third is a new process with shortest time came\n        if (!is_empty(&sQueue) && current_pcb != NULL) {\n            node *temp = peek(&sQueue);\n            if (temp != NULL) {\n                if (temp->priority < current_pcb->remaining_time) {\n                    // swap and stop current process\n                    kill(current_pcb->pid, SIGSTOP);\n                    print(current_time, current_pcb, NULL, 'p');\n                    current_pcb->state = READY; // back to Ready state\n                    push(&sQueue, current_pcb->remaining_time,\n                         current_pcb->id); // add this process to the end of the Queue\n\n                    current_pcb = NULL;\n                }\n            }\n        }\n        if (current_pcb == NULL && !is_empty(&sQueue)) {\n\n            node *temp = pop(&sQueue);\n            PCB get_process = {.id = temp->data};\n            current_pcb = hashmap_get(process_table, &get_process);\n            *shm_remain_time = current_pcb->remaining_time;\n            //  first time\n            if (current_pcb->pid == 0) {\n                int pid = fork();\n                if (pid == 0) {\n                    // child\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n\n                // continue scheduler\n                current_pcb->pid = pid; // update Pid of existing process\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_time - current_pcb->arrival_time;\n                print(current_time, current_pcb, NULL, 's');\n            }\n                // resumed after stopped\n            else {\n                kill(current_pcb->pid, SIGCONT);\n\n                // continue scheduler\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_time - (current_pcb->arrival_time + current_pcb->cum_runtime);\n\n                // if(current_pcb->id == 3){\n                //     printf(\"current %d arrivl %d -- cum %d -- waiting time %d\\n\", current_time, current_pcb->arrival_time, current_pcb->cum_runtime, current_pcb->waiting_time);\n                // }\n                print(current_time, current_pcb, NULL, 'r');\n\n            }\n        }\n    }\n    printf(\"\\nOut at time %d\\n\", current_time);\n    return current_time;\n}\n\nint HPF() {\n    minHeap hpf_queue = init_min_heap();\n\n    pcb_s *current_pcb;\n    bool process_is_currently_running = false;\n    int started_clk, current_clk=0;\n    int need_to_receive = TotalNumberOfProcesses;\n\n    int p_count = TotalNumberOfProcesses;\n\n    while (!is_empty(&hpf_queue) || p_count > 0 || process_is_currently_running) {\n\n        struct count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        current_clk = getClk();\n        int num_messages = c.count;\n        need_to_receive -= c.count;\n\n        while (num_messages > 0) {\n            // while still a process in the queue\n            // take it out\n            // add it to both the hpf_queue and its PCB to the processTable\n            struct process_struct coming_process;\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 0,\n                   !IPC_NOWAIT);\n            // you have that struct Now\n             PCB pcb =set_process(coming_process);\n            hashmap_set(process_table, &pcb);                             // this copies the content of the struct\n            push(&hpf_queue, coming_process.priority, coming_process.id); // add this process to the priority queue\n            printf(\"Received process with priority %d and id %d at time %d \\n\", coming_process.priority,\n                   coming_process.id, getClk());\n\n            num_messages--;\n        }\n        if (!is_empty(&hpf_queue) || process_is_currently_running) {\n            if (process_is_currently_running) {\n\n\n                if (current_clk - started_clk == current_pcb->remaining_time) {\n                    int st;\n                    int ret = wait(&st);\n                    int TA = current_clk - current_pcb->arrival_time;\n                    current_pcb->remaining_time = 0;\n                    current_pcb->waiting_time = TA - current_pcb->burst_time;\n                    float WTA = (float) TA / current_pcb->burst_time;\n                    p_count--;\n                    buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                    print(current_clk, current_pcb, NULL, 'd');\n                    OutputFinishedProcesses(current_clk, current_pcb, TA, WTA);\n\n                    hashmap_delete(process_table, current_pcb);\n                    process_is_currently_running = false;\n                }\n            }\n            if (!process_is_currently_running && !is_empty(&hpf_queue))\n            {\n                pcb_s get_process = {.id = peek(&hpf_queue)->data};\n                current_pcb = hashmap_get(process_table, &get_process);\n\n                (*shm_remain_time) = current_pcb->remaining_time;\n\n                int pid = fork();\n                if (pid == 0) {\n                    // child\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n                pair_t ret;\n                buddy_allocate(current_pcb->mem_size, &ret);\n                started_clk = current_clk;\n                process_is_currently_running = true;\n                // parent take the pid to the hashmap\n                current_pcb->pid = pid; // update Pid of existing process\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_clk - current_pcb->arrival_time;\n                current_pcb->memory_start_ind = ret.start_ind;\n                current_pcb->memory_end_ind = ret.end_ind;\n                print(current_clk, current_pcb, &ret, 'a');\n                print(current_clk, current_pcb, NULL, 's');\n                pop(&hpf_queue);\n            }\n        }\n    }\n    printf(\"\\nOut at time %d\\n\", current_clk);\n    return current_clk;\n}\n\nvoid scheduler_log() {\n    sch_log = fopen(\"scheduler.log\", \"w\");\n    if (sch_log == NULL) {\n        printf(\"error has been occured while creation or opening scheduler.log\\n\");\n    } else {\n        fprintf(sch_log, \"#At time x process y state arr w total z remain y wait k\\n\");\n    }\n}\n\nvoid memory_log() {\n    mem_log = fopen(\"memory.log\", \"w\");\n    if (mem_log == NULL) {\n        printf(\"error has been occured while creation or opening memory.log\\n\");\n    } else {\n        fprintf(mem_log, \"#At time x allocated y bytes for process z from i to j\\n\");\n    }\n}\n\nvoid scheduler_perf(int ProcessesCount) {\n    sch_perf = fopen(\"scheduler.perf\", \"w\");\n    if (sch_perf == NULL) {\n        printf(\"error has been occured while creation or opening scheduler.perf\\n\");\n    } else {\n        float CPU_Utilization = ((float) TotalRunTime / getClk()) * 100;\n        fprintf(sch_perf, \"CPU utilization = %.2f %%\\n\", CPU_Utilization);\n        fprintf(sch_perf, \"Avg WTA = %.2f\\n\", ((float) TotalWTA) / ProcessesCount);\n        fprintf(sch_perf, \"Avg Waiting = %.2f\\n\", ((float) TotalWaitingTime) / ProcessesCount);\n        fprintf(sch_perf, \"Std WTA = %.2f\\n\", CalcStdWTA(((float) TotalWTA) / ProcessesCount));\n    }\n}\n\nvoid OutputFinishedProcesses(int CurrTime, PCB *current_pcb, int TA, float WTA) {\n    // printing in a file\n    fprintf(sch_log, \"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\", CurrTime,\n            current_pcb->id,\n            current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time, current_pcb->waiting_time,\n            TA, WTA);\n\n    printf(RED \"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\" RESET,\n           CurrTime, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n           current_pcb->waiting_time, TA, WTA);\n    // update stats variables\n    TotalRunTime += current_pcb->burst_time;\n    TotalWTA += WTA;\n    TotalWaitingTime += current_pcb->waiting_time;\n    WeightedTA[WTAIterator] = WTA;\n    WTAIterator++;\n}\n\nvoid print(int CurrentTime, PCB *current_pcb, pair_t *Index, char type) {\n    switch (type) {\n        case 's':   //starting process\n            fprintf(sch_log, \"At time %d process %d started arr %d total %d remain %d wait %d\\n\", CurrentTime,\n                    current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                    current_pcb->waiting_time);\n\n            printf(\"At time %d process %d started arr %d total %d remain %d wait %d\\n\", CurrentTime, current_pcb->id,\n                   current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                   current_pcb->waiting_time);\n            break;\n\n        case 'p' :  //stopping process\n            fprintf(sch_log, \"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", CurrentTime,\n                    current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                    current_pcb->waiting_time);\n            printf(\"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", CurrentTime, current_pcb->id,\n                   current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                   current_pcb->waiting_time);\n            break;\n\n        case 'r' :  //resuming process\n            fprintf(sch_log, \"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\", CurrentTime,\n                    current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                    current_pcb->waiting_time);\n\n            printf(\"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\", CurrentTime, current_pcb->id,\n                   current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                   current_pcb->waiting_time);\n            break;\n\n        case 'd' :  //memory dellocation\n            printf(\"At time %d freed %d bytes for process %d from %d to %d\\n\",\n                   CurrentTime, current_pcb->mem_size, current_pcb->id, current_pcb->memory_start_ind,\n                   current_pcb->memory_end_ind);\n            fprintf(mem_log, \"At time %d freed %d bytes for process %d from %d to %d\\n\",\n                    CurrentTime, current_pcb->mem_size, current_pcb->id, current_pcb->memory_start_ind,\n                    current_pcb->memory_end_ind);\n            break;\n\n        case 'a' :  //memory allocation\n            printf(CYN \"At time %d allocated %d bytes for process %d from %d to %d\\n\" RESET, CurrentTime,\n                   current_pcb->mem_size,\n                   current_pcb->id, Index->start_ind, Index->end_ind);\n\n            fprintf(mem_log, \"At time %d allocated %d bytes for process %d from %d to %d\\n\", CurrentTime,\n                    current_pcb->mem_size,\n                    current_pcb->id, Index->start_ind, Index->end_ind);\n            break;\n        default:\n            break;\n    }\n}\n\nfloat CalcStdWTA(float AvgWTA) {\n    float numerator = 0;\n    float Variance = 0;\n    for (int i = 0; i < TotalNumberOfProcesses; i++) {\n        numerator += pow((WeightedTA[i] - AvgWTA), 2);\n    }\n    Variance = numerator / TotalNumberOfProcesses;\n    return sqrt(Variance);\n}\n\nvoid FinishPrinting() {\n    fclose(sch_log);\n    fclose(sch_perf);\n    fclose(mem_log);\n    free(WeightedTA);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.c b/scheduler.c
--- a/scheduler.c	(revision 7e111f33249e37bbf75b675b4b7643642ec3e4d5)
+++ b/scheduler.c	(date 1653924508198)
@@ -175,7 +175,7 @@
     bool process_is_currently_running = false;
     int curr = 0;
     while (!circular_is_empty(&RRqueue) || p_count > 0) {
-        printf("\n in loop \n");
+
         // First check if any process has come
         struct count_msg c = {.count = 0};
         if (more_processes_coming || need_to_receive > 0)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"CMakeRunConfigurationManager\">\n    <generated />\n  </component>\n  <component name=\"CMakeSettings\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"eb74cbae-2b8d-4ad0-b305-4f35558e8945\" name=\"Changes\" comment=\"small changes\">\n      <change beforePath=\"$PROJECT_DIR$/scheduler.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/scheduler.c\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExternalProjectsData\">\n    <projectState path=\"$PROJECT_DIR$\">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$/../..\" value=\"Hany\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/../..\" />\n  </component>\n  <component name=\"MakefileLocalSettings\">\n    <option name=\"availableProjects\">\n      <map>\n        <entry>\n          <key>\n            <ExternalProjectPojo>\n              <option name=\"name\" value=\"code\" />\n              <option name=\"path\" value=\"$PROJECT_DIR$\" />\n            </ExternalProjectPojo>\n          </key>\n          <value>\n            <list>\n              <ExternalProjectPojo>\n                <option name=\"name\" value=\"code\" />\n                <option name=\"path\" value=\"$PROJECT_DIR$\" />\n              </ExternalProjectPojo>\n            </list>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"projectSyncType\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"RE_IMPORT\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"MakefilesProjectLoadingState\">\n    <option name=\"doClean\" value=\"false\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectApplicationVersion\">\n    <option name=\"ide\" value=\"CLion\" />\n    <option name=\"majorVersion\" value=\"2022\" />\n    <option name=\"minorVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"28iaeKe0W5RiQB3GpPOuj0kNKuE\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;Git.Branch.Popup.ShowAllRemotes&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\n    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,\n    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,\n    &quot;structure.view.defaults.are.configured&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\n      </method>\n    </configuration>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"eb74cbae-2b8d-4ad0-b305-4f35558e8945\" name=\"Changes\" comment=\"\" />\n      <created>1651701954964</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1651701954964</updated>\n      <workItem from=\"1651701956794\" duration=\"2891000\" />\n      <workItem from=\"1651741541771\" duration=\"7000\" />\n      <workItem from=\"1651741795977\" duration=\"8000\" />\n      <workItem from=\"1651741912093\" duration=\"1001000\" />\n      <workItem from=\"1651746733229\" duration=\"3286000\" />\n      <workItem from=\"1651833951326\" duration=\"8093000\" />\n      <workItem from=\"1651950945153\" duration=\"1337000\" />\n      <workItem from=\"1652560242591\" duration=\"1000\" />\n      <workItem from=\"1652563360727\" duration=\"6374000\" />\n      <workItem from=\"1652953668020\" duration=\"793000\" />\n      <workItem from=\"1652956405104\" duration=\"7000\" />\n      <workItem from=\"1653582405007\" duration=\"2572000\" />\n      <workItem from=\"1653673405201\" duration=\"11868000\" />\n      <workItem from=\"1653687584058\" duration=\"3847000\" />\n      <workItem from=\"1653721249854\" duration=\"5486000\" />\n      <workItem from=\"1653735419407\" duration=\"4830000\" />\n      <workItem from=\"1653741516439\" duration=\"1000\" />\n      <workItem from=\"1653851920841\" duration=\"9856000\" />\n      <workItem from=\"1653919655343\" duration=\"3813000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"new phase\">\n      <created>1651702962617</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651702962617</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"before main changes\">\n      <created>1651747442807</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651747442807</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"started buddy\">\n      <created>1651750011140</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651750011140</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"initial tests buddy\">\n      <created>1651839280574</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651839280574</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"some tests and passed\">\n      <created>1651839929289</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651839929289</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"more tests passed\">\n      <created>1651842015623</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651842015623</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"more tests passed\">\n      <created>1652563393266</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563393266</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"returned to correct version\">\n      <created>1652563882138</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563882138</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"returned to correct version\">\n      <created>1652563891556</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563891556</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"Before changing Remaing Time\">\n      <created>1652566926737</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652566926737</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\" changing Remaining Time\">\n      <created>1652569218486</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652569218486</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"merged hany\">\n      <created>1653583576539</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653583576539</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"merged fady\">\n      <created>1653586846073</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653586846073</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"before changing RR\">\n      <created>1653678589334</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653678589335</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"after Merge\">\n      <created>1653723337140</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653723337140</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"fixed some Bugs\">\n      <created>1653733518741</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653733518741</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"small changes\">\n      <created>1653863519441</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1653863519441</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"18\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"new phase\" />\n    <MESSAGE value=\"before main changes\" />\n    <MESSAGE value=\"started buddy\" />\n    <MESSAGE value=\"initial tests buddy\" />\n    <MESSAGE value=\"some tests and passed\" />\n    <MESSAGE value=\"more tests passed\" />\n    <MESSAGE value=\"returned to correct version\" />\n    <MESSAGE value=\"Before changing Remaing Time\" />\n    <MESSAGE value=\" changing Remaining Time\" />\n    <MESSAGE value=\"merged hany\" />\n    <MESSAGE value=\"merged fady\" />\n    <MESSAGE value=\"before changing RR\" />\n    <MESSAGE value=\"after Merge\" />\n    <MESSAGE value=\"fixed some Bugs\" />\n    <MESSAGE value=\"small changes\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"small changes\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7e111f33249e37bbf75b675b4b7643642ec3e4d5)
+++ b/.idea/workspace.xml	(date 1653924618082)
@@ -12,8 +12,11 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="eb74cbae-2b8d-4ad0-b305-4f35558e8945" name="Changes" comment="small changes">
+    <list default="true" id="eb74cbae-2b8d-4ad0-b305-4f35558e8945" name="Changes" comment="finish">
+      <change beforePath="$PROJECT_DIR$/memory.log" beforeDir="false" afterPath="$PROJECT_DIR$/memory.log" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/scheduler.c" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/scheduler.log" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.log" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/scheduler.perf" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.perf" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -248,7 +251,14 @@
       <option name="project" value="LOCAL" />
       <updated>1653863519441</updated>
     </task>
-    <option name="localTasksCounter" value="18" />
+    <task id="LOCAL-00018" summary="finish">
+      <created>1653924305426</created>
+      <option name="number" value="00018" />
+      <option name="presentableId" value="LOCAL-00018" />
+      <option name="project" value="LOCAL" />
+      <updated>1653924305426</updated>
+    </task>
+    <option name="localTasksCounter" value="19" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -281,6 +291,7 @@
     <MESSAGE value="after Merge" />
     <MESSAGE value="fixed some Bugs" />
     <MESSAGE value="small changes" />
-    <option name="LAST_COMMIT_MESSAGE" value="small changes" />
+    <MESSAGE value="finish" />
+    <option name="LAST_COMMIT_MESSAGE" value="finish" />
   </component>
 </project>
\ No newline at end of file
