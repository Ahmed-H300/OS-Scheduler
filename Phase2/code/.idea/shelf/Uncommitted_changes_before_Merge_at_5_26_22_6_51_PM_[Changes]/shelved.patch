Index: scheduler.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#At time x process y state arr w total z remain y wait k\nAt time 3 process 1 started arr 3 total 10 remain 10 wait 0\nAt time 12 process 1 stopped arr 3 total 10 remain 1 wait 0\nAt time 12 process 2 started arr 11 total 27 remain 27 wait 1\nAt time 13 process 2 stopped arr 11 total 27 remain 26 wait 1\nAt time 13 process 1 resumed arr 3 total 10 remain 1 wait 1\nAt time 14 process 1 finished arr 3 total 10 remain 0 wait 1 TA 11 WTA 1.10\nAt time 14 process 2 resumed arr 11 total 27 remain 26 wait 2\nAt time 20 process 2 stopped arr 11 total 27 remain 20 wait 2\nAt time 20 process 3 started arr 19 total 29 remain 29 wait 1\nAt time 21 process 3 stopped arr 19 total 29 remain 28 wait 1\nAt time 21 process 2 resumed arr 11 total 27 remain 20 wait 3\nAt time 22 process 2 stopped arr 11 total 27 remain 19 wait 3\nAt time 22 process 3 resumed arr 19 total 29 remain 28 wait 2\nAt time 23 process 3 stopped arr 19 total 29 remain 27 wait 2\nAt time 23 process 2 resumed arr 11 total 27 remain 19 wait 4\nAt time 24 process 2 stopped arr 11 total 27 remain 18 wait 4\nAt time 24 process 3 resumed arr 19 total 29 remain 27 wait 3\nAt time 25 process 3 stopped arr 19 total 29 remain 26 wait 3\nAt time 25 process 2 resumed arr 11 total 27 remain 18 wait 5\nAt time 26 process 2 stopped arr 11 total 27 remain 17 wait 5\nAt time 26 process 3 resumed arr 19 total 29 remain 26 wait 4\nAt time 27 process 3 stopped arr 19 total 29 remain 25 wait 4\nAt time 27 process 2 resumed arr 11 total 27 remain 17 wait 6\nAt time 28 process 2 stopped arr 11 total 27 remain 16 wait 6\nAt time 28 process 3 resumed arr 19 total 29 remain 25 wait 5\nAt time 29 process 3 stopped arr 19 total 29 remain 24 wait 5\nAt time 29 process 2 resumed arr 11 total 27 remain 16 wait 7\nAt time 30 process 2 stopped arr 11 total 27 remain 15 wait 7\nAt time 30 process 4 started arr 28 total 8 remain 8 wait 2\nAt time 31 process 4 stopped arr 28 total 8 remain 7 wait 2\nAt time 31 process 3 resumed arr 19 total 29 remain 24 wait 7\nAt time 32 process 3 stopped arr 19 total 29 remain 23 wait 7\nAt time 32 process 2 resumed arr 11 total 27 remain 15 wait 9\nAt time 33 process 2 stopped arr 11 total 27 remain 14 wait 9\nAt time 33 process 4 resumed arr 28 total 8 remain 7 wait 4\nAt time 34 process 4 stopped arr 28 total 8 remain 6 wait 4\nAt time 34 process 3 resumed arr 19 total 29 remain 23 wait 9\nAt time 35 process 3 stopped arr 19 total 29 remain 22 wait 9\nAt time 35 process 2 resumed arr 11 total 27 remain 14 wait 11\nAt time 36 process 2 stopped arr 11 total 27 remain 13 wait 11\nAt time 36 process 4 resumed arr 28 total 8 remain 6 wait 6\nAt time 37 process 4 stopped arr 28 total 8 remain 5 wait 6\nAt time 37 process 3 resumed arr 19 total 29 remain 22 wait 11\nAt time 38 process 3 stopped arr 19 total 29 remain 21 wait 11\nAt time 38 process 2 resumed arr 11 total 27 remain 13 wait 13\nAt time 39 process 2 stopped arr 11 total 27 remain 12 wait 13\nAt time 39 process 4 resumed arr 28 total 8 remain 5 wait 8\nAt time 40 process 4 stopped arr 28 total 8 remain 4 wait 8\nAt time 40 process 3 resumed arr 19 total 29 remain 21 wait 13\nAt time 41 process 3 stopped arr 19 total 29 remain 20 wait 13\nAt time 41 process 2 resumed arr 11 total 27 remain 12 wait 15\nAt time 42 process 2 stopped arr 11 total 27 remain 11 wait 15\nAt time 42 process 4 resumed arr 28 total 8 remain 4 wait 10\nAt time 43 process 4 stopped arr 28 total 8 remain 3 wait 10\nAt time 43 process 3 resumed arr 19 total 29 remain 20 wait 15\nAt time 44 process 3 stopped arr 19 total 29 remain 19 wait 15\nAt time 44 process 2 resumed arr 11 total 27 remain 11 wait 17\nAt time 45 process 2 stopped arr 11 total 27 remain 10 wait 17\nAt time 45 process 4 resumed arr 28 total 8 remain 3 wait 12\nAt time 46 process 4 stopped arr 28 total 8 remain 2 wait 12\nAt time 46 process 3 resumed arr 19 total 29 remain 19 wait 17\nAt time 47 process 3 stopped arr 19 total 29 remain 18 wait 17\nAt time 47 process 2 resumed arr 11 total 27 remain 10 wait 19\nAt time 48 process 2 stopped arr 11 total 27 remain 9 wait 19\nAt time 48 process 4 resumed arr 28 total 8 remain 2 wait 14\nAt time 49 process 4 stopped arr 28 total 8 remain 1 wait 14\nAt time 49 process 3 resumed arr 19 total 29 remain 18 wait 19\nAt time 50 process 3 stopped arr 19 total 29 remain 17 wait 19\nAt time 50 process 2 resumed arr 11 total 27 remain 9 wait 21\nAt time 51 process 2 stopped arr 11 total 27 remain 8 wait 21\nAt time 51 process 4 resumed arr 28 total 8 remain 1 wait 16\nAt time 52 process 4 finished arr 28 total 8 remain 0 wait 16 TA 24 WTA 3.00\nAt time 52 process 3 resumed arr 19 total 29 remain 17 wait 21\nAt time 53 process 3 stopped arr 19 total 29 remain 16 wait 21\nAt time 53 process 2 resumed arr 11 total 27 remain 8 wait 23\nAt time 54 process 2 stopped arr 11 total 27 remain 7 wait 23\nAt time 54 process 3 resumed arr 19 total 29 remain 16 wait 22\nAt time 55 process 3 stopped arr 19 total 29 remain 15 wait 22\nAt time 55 process 2 resumed arr 11 total 27 remain 7 wait 24\nAt time 56 process 2 stopped arr 11 total 27 remain 6 wait 24\nAt time 56 process 3 resumed arr 19 total 29 remain 15 wait 23\nAt time 57 process 3 stopped arr 19 total 29 remain 14 wait 23\nAt time 57 process 2 resumed arr 11 total 27 remain 6 wait 25\nAt time 58 process 2 stopped arr 11 total 27 remain 5 wait 25\nAt time 58 process 3 resumed arr 19 total 29 remain 14 wait 24\nAt time 59 process 3 stopped arr 19 total 29 remain 13 wait 24\nAt time 59 process 2 resumed arr 11 total 27 remain 5 wait 26\nAt time 60 process 2 stopped arr 11 total 27 remain 4 wait 26\nAt time 60 process 3 resumed arr 19 total 29 remain 13 wait 25\nAt time 61 process 3 stopped arr 19 total 29 remain 12 wait 25\nAt time 61 process 2 resumed arr 11 total 27 remain 4 wait 27\nAt time 62 process 2 stopped arr 11 total 27 remain 3 wait 27\nAt time 62 process 3 resumed arr 19 total 29 remain 12 wait 26\nAt time 63 process 3 stopped arr 19 total 29 remain 11 wait 26\nAt time 63 process 2 resumed arr 11 total 27 remain 3 wait 28\nAt time 64 process 2 stopped arr 11 total 27 remain 2 wait 28\nAt time 64 process 3 resumed arr 19 total 29 remain 11 wait 27\nAt time 65 process 3 stopped arr 19 total 29 remain 10 wait 27\nAt time 65 process 2 resumed arr 11 total 27 remain 2 wait 29\nAt time 66 process 2 stopped arr 11 total 27 remain 1 wait 29\nAt time 66 process 3 resumed arr 19 total 29 remain 10 wait 28\nAt time 67 process 3 stopped arr 19 total 29 remain 9 wait 28\nAt time 67 process 2 resumed arr 11 total 27 remain 1 wait 30\nAt time 68 process 2 finished arr 11 total 27 remain 0 wait 30 TA 57 WTA 2.11\nAt time 68 process 3 resumed arr 19 total 29 remain 9 wait 29\nAt time 77 process 3 finished arr 19 total 29 remain 0 wait 29 TA 58 WTA 2.00\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.log b/scheduler.log
--- a/scheduler.log	(revision 6dc585cd9c88bae4ff81e79d89424b3e43705ad4)
+++ b/scheduler.log	(date 1653583816165)
@@ -1,107 +1,11 @@
 #At time x process y state arr w total z remain y wait k
 At time 3 process 1 started arr 3 total 10 remain 10 wait 0
-At time 12 process 1 stopped arr 3 total 10 remain 1 wait 0
-At time 12 process 2 started arr 11 total 27 remain 27 wait 1
-At time 13 process 2 stopped arr 11 total 27 remain 26 wait 1
-At time 13 process 1 resumed arr 3 total 10 remain 1 wait 1
-At time 14 process 1 finished arr 3 total 10 remain 0 wait 1 TA 11 WTA 1.10
-At time 14 process 2 resumed arr 11 total 27 remain 26 wait 2
-At time 20 process 2 stopped arr 11 total 27 remain 20 wait 2
-At time 20 process 3 started arr 19 total 29 remain 29 wait 1
-At time 21 process 3 stopped arr 19 total 29 remain 28 wait 1
-At time 21 process 2 resumed arr 11 total 27 remain 20 wait 3
-At time 22 process 2 stopped arr 11 total 27 remain 19 wait 3
-At time 22 process 3 resumed arr 19 total 29 remain 28 wait 2
-At time 23 process 3 stopped arr 19 total 29 remain 27 wait 2
-At time 23 process 2 resumed arr 11 total 27 remain 19 wait 4
-At time 24 process 2 stopped arr 11 total 27 remain 18 wait 4
-At time 24 process 3 resumed arr 19 total 29 remain 27 wait 3
-At time 25 process 3 stopped arr 19 total 29 remain 26 wait 3
-At time 25 process 2 resumed arr 11 total 27 remain 18 wait 5
-At time 26 process 2 stopped arr 11 total 27 remain 17 wait 5
-At time 26 process 3 resumed arr 19 total 29 remain 26 wait 4
-At time 27 process 3 stopped arr 19 total 29 remain 25 wait 4
-At time 27 process 2 resumed arr 11 total 27 remain 17 wait 6
-At time 28 process 2 stopped arr 11 total 27 remain 16 wait 6
-At time 28 process 3 resumed arr 19 total 29 remain 25 wait 5
-At time 29 process 3 stopped arr 19 total 29 remain 24 wait 5
-At time 29 process 2 resumed arr 11 total 27 remain 16 wait 7
-At time 30 process 2 stopped arr 11 total 27 remain 15 wait 7
-At time 30 process 4 started arr 28 total 8 remain 8 wait 2
-At time 31 process 4 stopped arr 28 total 8 remain 7 wait 2
-At time 31 process 3 resumed arr 19 total 29 remain 24 wait 7
-At time 32 process 3 stopped arr 19 total 29 remain 23 wait 7
-At time 32 process 2 resumed arr 11 total 27 remain 15 wait 9
-At time 33 process 2 stopped arr 11 total 27 remain 14 wait 9
-At time 33 process 4 resumed arr 28 total 8 remain 7 wait 4
-At time 34 process 4 stopped arr 28 total 8 remain 6 wait 4
-At time 34 process 3 resumed arr 19 total 29 remain 23 wait 9
-At time 35 process 3 stopped arr 19 total 29 remain 22 wait 9
-At time 35 process 2 resumed arr 11 total 27 remain 14 wait 11
-At time 36 process 2 stopped arr 11 total 27 remain 13 wait 11
-At time 36 process 4 resumed arr 28 total 8 remain 6 wait 6
-At time 37 process 4 stopped arr 28 total 8 remain 5 wait 6
-At time 37 process 3 resumed arr 19 total 29 remain 22 wait 11
-At time 38 process 3 stopped arr 19 total 29 remain 21 wait 11
-At time 38 process 2 resumed arr 11 total 27 remain 13 wait 13
-At time 39 process 2 stopped arr 11 total 27 remain 12 wait 13
-At time 39 process 4 resumed arr 28 total 8 remain 5 wait 8
-At time 40 process 4 stopped arr 28 total 8 remain 4 wait 8
-At time 40 process 3 resumed arr 19 total 29 remain 21 wait 13
-At time 41 process 3 stopped arr 19 total 29 remain 20 wait 13
-At time 41 process 2 resumed arr 11 total 27 remain 12 wait 15
-At time 42 process 2 stopped arr 11 total 27 remain 11 wait 15
-At time 42 process 4 resumed arr 28 total 8 remain 4 wait 10
-At time 43 process 4 stopped arr 28 total 8 remain 3 wait 10
-At time 43 process 3 resumed arr 19 total 29 remain 20 wait 15
-At time 44 process 3 stopped arr 19 total 29 remain 19 wait 15
-At time 44 process 2 resumed arr 11 total 27 remain 11 wait 17
-At time 45 process 2 stopped arr 11 total 27 remain 10 wait 17
-At time 45 process 4 resumed arr 28 total 8 remain 3 wait 12
-At time 46 process 4 stopped arr 28 total 8 remain 2 wait 12
-At time 46 process 3 resumed arr 19 total 29 remain 19 wait 17
-At time 47 process 3 stopped arr 19 total 29 remain 18 wait 17
-At time 47 process 2 resumed arr 11 total 27 remain 10 wait 19
-At time 48 process 2 stopped arr 11 total 27 remain 9 wait 19
-At time 48 process 4 resumed arr 28 total 8 remain 2 wait 14
-At time 49 process 4 stopped arr 28 total 8 remain 1 wait 14
-At time 49 process 3 resumed arr 19 total 29 remain 18 wait 19
-At time 50 process 3 stopped arr 19 total 29 remain 17 wait 19
-At time 50 process 2 resumed arr 11 total 27 remain 9 wait 21
-At time 51 process 2 stopped arr 11 total 27 remain 8 wait 21
-At time 51 process 4 resumed arr 28 total 8 remain 1 wait 16
-At time 52 process 4 finished arr 28 total 8 remain 0 wait 16 TA 24 WTA 3.00
-At time 52 process 3 resumed arr 19 total 29 remain 17 wait 21
-At time 53 process 3 stopped arr 19 total 29 remain 16 wait 21
-At time 53 process 2 resumed arr 11 total 27 remain 8 wait 23
-At time 54 process 2 stopped arr 11 total 27 remain 7 wait 23
-At time 54 process 3 resumed arr 19 total 29 remain 16 wait 22
-At time 55 process 3 stopped arr 19 total 29 remain 15 wait 22
-At time 55 process 2 resumed arr 11 total 27 remain 7 wait 24
-At time 56 process 2 stopped arr 11 total 27 remain 6 wait 24
-At time 56 process 3 resumed arr 19 total 29 remain 15 wait 23
-At time 57 process 3 stopped arr 19 total 29 remain 14 wait 23
-At time 57 process 2 resumed arr 11 total 27 remain 6 wait 25
-At time 58 process 2 stopped arr 11 total 27 remain 5 wait 25
-At time 58 process 3 resumed arr 19 total 29 remain 14 wait 24
-At time 59 process 3 stopped arr 19 total 29 remain 13 wait 24
-At time 59 process 2 resumed arr 11 total 27 remain 5 wait 26
-At time 60 process 2 stopped arr 11 total 27 remain 4 wait 26
-At time 60 process 3 resumed arr 19 total 29 remain 13 wait 25
-At time 61 process 3 stopped arr 19 total 29 remain 12 wait 25
-At time 61 process 2 resumed arr 11 total 27 remain 4 wait 27
-At time 62 process 2 stopped arr 11 total 27 remain 3 wait 27
-At time 62 process 3 resumed arr 19 total 29 remain 12 wait 26
-At time 63 process 3 stopped arr 19 total 29 remain 11 wait 26
-At time 63 process 2 resumed arr 11 total 27 remain 3 wait 28
-At time 64 process 2 stopped arr 11 total 27 remain 2 wait 28
-At time 64 process 3 resumed arr 19 total 29 remain 11 wait 27
-At time 65 process 3 stopped arr 19 total 29 remain 10 wait 27
-At time 65 process 2 resumed arr 11 total 27 remain 2 wait 29
-At time 66 process 2 stopped arr 11 total 27 remain 1 wait 29
-At time 66 process 3 resumed arr 19 total 29 remain 10 wait 28
-At time 67 process 3 stopped arr 19 total 29 remain 9 wait 28
-At time 67 process 2 resumed arr 11 total 27 remain 1 wait 30
-At time 68 process 2 finished arr 11 total 27 remain 0 wait 30 TA 57 WTA 2.11
-At time 68 process 3 resumed arr 19 total 29 remain 9 wait 29
+At time 13 process 1 finished arr 3 total 10 remain 0 wait 0 TA 10 WTA 1.00
+At time 13 process 2 started arr 11 total 27 remain 27 wait 2
+At time 29 process 2 stopped arr 11 total 27 remain 11 wait 2
+At time 29 process 4 started arr 28 total 8 remain 8 wait 1
+At time 37 process 4 finished arr 28 total 8 remain 0 wait 1 TA 9 WTA 1.12
+At time 37 process 2 resumed arr 11 total 27 remain 11 wait 10
+At time 48 process 2 finished arr 11 total 27 remain 0 wait 10 TA 37 WTA 1.37
+At time 48 process 3 started arr 19 total 29 remain 29 wait 29
 At time 77 process 3 finished arr 19 total 29 remain 0 wait 29 TA 58 WTA 2.00
Index: Makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>build:\n\tgcc process_generator.c -o process_generator.out\n\tgcc clk.c -o clk.out\n\tgcc scheduler.c hashmap.c queue.c -lm priority_queue.c -o scheduler.out\n\tgcc process.c -o process.out\n\tgcc test_generator.c -o test_generator.out\n\nclean:\n\trm -f *.out  processes.txt\n\n\nrun:\n\t./process_generator.out 1 1\nall: run\n\ngenerate:\n\tgcc test_generator.c -o test_generator.out\n\t./test_generator.out\n\ntest: build\n\t./process_generator.out 1 1\n\n\nbuddy:\n\tgcc -o hey -g  buddy_core.c -lm\n\t./hey\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Makefile b/Makefile
--- a/Makefile	(revision 6dc585cd9c88bae4ff81e79d89424b3e43705ad4)
+++ b/Makefile	(date 1653583704868)
@@ -18,7 +18,7 @@
 	./test_generator.out
 
 test: build
-	./process_generator.out 1 1
+	./process_generator.out 3 1
 
 
 buddy:
Index: scheduler.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"headers.h\"\n#include \"hashmap.h\"\n#include \"circular_queue.h\"\n#include \"priority_queue.h\"\n#include \"math.h\"\n#include \"queue.h\"\n#include \"buddy_core.c\"\n\n#define pcb_s struct PCB\n\n\n\nFILE *sch_log, *sch_perf,*mem_log;\nint TotalWaitingTime = 0;\nint TotalWTA = 0;\nint TotalRunTime = 0;\nint TotalNumberOfProcesses = 0;\nint *WeightedTA = NULL;\nint WTAIterator = 0;\n\nvoid OutputFinishedProcesses(int CurrTime, int ID, int ArrTime, int RunningTime, int RemainTime, int WaitingTime, int TA, float WTA);\n\nvoid scheduler_log();\n\nvoid memory_log();\n\nfloat CalcStdWTA(float AvgWTA);\n\nvoid scheduler_perf(int ProcessCount);\n\nvoid FinishPrinting();\n\nvoid RR2(int quantum);\n\nvoid SRTN();\n\nvoid HPF();\n\n//@Ahmed-H300\n// change it to typedef instead of struct\ntypedef struct PCB\n{\n    int id; // this is the key in the hashmap\n    int pid;\n    int arrival_time;\n    int priority;\n    short state;\n    int cum_runtime;\n    int burst_time;\n    int remaining_time;\n    int waiting_time;\n    //...............................P2\n    int mem_size;\n    int memory_start_ind;\n    int memory_end_ind;\n} PCB;\n\n// 3 functions related to the hashmap\nint process_compare(const void *a, const void *b, void *udata)\n{\n    const struct PCB *process_a = a;\n    const struct PCB *process_b = b;\n    return (process_a->id - process_b->id);\n}\n\nbool process_iter(const void *item, void *udata)\n{\n    const struct PCB *process = item;\n    printf(\"process: (id=%d) (arrivalTime=%d) (runTime=%d) (priority=%d) (pid=%d) (state=%d) (remainingTime=%d)\\n\",\n           process->pid, process->arrival_time, process->cum_runtime, process->priority, process->pid, process->state,\n           process->remaining_time);\n    return true;\n}\n\nuint64_t process_hash(const void *item, uint64_t seed0, uint64_t seed1)\n{\n    const struct PCB *process = item;\n    return hashmap_sip(&process->id, sizeof(process->id), seed0, seed1);\n}\n\n// TODO init this in the main of the scheduler\nstruct hashmap *process_table;\nint process_msg_queue;\n\n// when process generator tells us that there is no more to come\n// set this to false\n\nbool more_processes_coming = true;\n\nvoid set_no_more_processes_coming(int signum)\n{\n    more_processes_coming = false;\n}\n\nint main(int argc, char *argv[])\n{\n    // process Gen sends a SIGUSR1 to sch to tell than no more processes are coming\n    signal(SIGUSR1, set_no_more_processes_coming);\n\n    // create and open files\n    scheduler_log();\n    memory_log();\n    initClk();\n    buddy_init();\n\n    int remain_time_shmid = shmget(REMAIN_TIME_SHMKEY, 4, IPC_CREAT | 0644);\n    if (remain_time_shmid == -1)\n        perror(\"cant init remaining time shm: \\n\");\n    shm_remain_time = (int *)shmat(remain_time_shmid, NULL, 0);\n    *shm_remain_time = -1;\n\n    process_table = hashmap_new(sizeof(PCB), 0, 0, 0, process_hash, process_compare, NULL);\n\n    struct chosen_algorithm coming;\n    int key_id = ftok(\"keyfile\", 'q');\n    process_msg_queue = msgget(key_id, 0666 | IPC_CREAT);\n    msgrcv(process_msg_queue, &coming, sizeof(coming) - sizeof(coming.mtype), ALGO_TYPE, !IPC_NOWAIT);\n\n    // Set number of processes to use in statistics (scheduler.perf)\n    TotalNumberOfProcesses = coming.NumOfProcesses;\n    WeightedTA = (int *)malloc(sizeof(int) * TotalNumberOfProcesses);\n\n    printf(\"\\nchosen Algo is %d\\n\", coming.algo);\n\n    switch (coming.algo)\n    {\n    case 1:\n        printf(\"RR with q=%d at time: %d\\n\", coming.arg, getClk());\n        RR2(coming.arg);\n        break;\n\n    case 2:\n        printf(\"HPF\\n\");\n        HPF();\n        break;\n    case 3:\n        printf(\"SRTN\\n\");\n        SRTN();\n        break;\n    }\n    printf(\"DONE scheduler\\n\");\n    scheduler_perf(TotalNumberOfProcesses);\n    FinishPrinting();\n    // upon termination release the clock resources.\n    hashmap_free(process_table);\n    shmctl(remain_time_shmid, IPC_RMID, NULL);\n    destroyClk(true);\n}\n\nvoid RR2(int quantum)\n{\n    /**\n     * i loop all the time\n     * till a variable tells me that there is no more processes coming\n     * this is when i quit\n     * All the processes that in the circular queue are in the process_table\n     * when finished -> u delete from both\n     * @bug: if the process gen sends a SIGUSR1 immediately after sending Processes -> it finishes too\n     *       @solution -> make Process gen sleep for a 1 sec or st after sending all\n     **/\n    struct c_queue RRqueue;\n    circular_init_queue(&RRqueue);\n\n    queue waiting_queue = initQueue(); // to receive in it\n\n    PCB *current_pcb;\n    int curr_q_start;\n    int p_count = TotalNumberOfProcesses;\n    int need_to_receive = TotalNumberOfProcesses;\n    bool process_is_currently_running = false;\n    bool can_insert = true;\n\n    while (!circular_is_empty(&RRqueue) || p_count > 0)\n    {\n\n        // First check if any process has come\n        struct count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        int num_messages = c.count;\n        need_to_receive -= c.count;\n        while (num_messages > 0)\n        {\n            // while still a process in the queue\n            // take it out\n            // add it to both the RRqueue and its PCB to the processTable\n            process_struct coming_process;\n\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 1,\n                   !IPC_NOWAIT);\n            printf(\"\\nrecv process with id: %d at time %d\\n\", coming_process.id, getClk());\n            //  you have that struct Now\n            struct PCB pcb;\n            pcb.id = coming_process.id;\n            pcb.pid = 0;\n            pcb.priority = coming_process.priority;\n            pcb.arrival_time = coming_process.arrival;\n            pcb.cum_runtime = 0;\n            pcb.remaining_time = coming_process.runtime; // at the beginning\n            pcb.burst_time = coming_process.runtime;     // at the beginning\n            pcb.mem_size = coming_process.memsize;\n            hashmap_set(process_table, &pcb); // this copies the content of the struct\n            // circular_enQueue(&RRqueue, coming_process.id); // add this process to the end of the Queue\n\n            pushQueue(&waiting_queue, coming_process.id); // add to the waiting list and will see if you can Run\n            num_messages--;\n        }\n        //  printf(\"curr is %d: %d\\n\", getClk(), more_processes_coming);\n        // there is a process in the Queue and first time to start\n\n        int curr = getClk();\n\n        // hashmap_scan(process_table, process_iter, NULL);\n        // if its time ended or its quantum -> switch (Advance front)\n        // otherwise just let it run in peace\n        // if there is a running process -> see if it can be finished or not\n        bool process_has_finished = false;\n        if (process_is_currently_running)\n        {\n            current_pcb = hashmap_get(process_table, &(PCB){.id = RRqueue.front->data});\n\n            if (curr - curr_q_start >= current_pcb->remaining_time)\n            { // that process will be finished\n                int st;\n                //*shm_remain_time = 0;\n                current_pcb->remaining_time = 0;\n                current_pcb->cum_runtime = current_pcb->burst_time;\n                int ret = wait(&st);\n                if (ret == -1)\n                {\n                    perror(\"error in waiting the Process:\");\n                }\n                // if a process ended normally -- you're sure that the signal came from a dead process -- not stopped or resumed\n                int TA = curr - current_pcb->arrival_time;\n                current_pcb->waiting_time = TA - current_pcb->burst_time;\n                float WTA = (float)TA / current_pcb->burst_time;\n                OutputFinishedProcesses(curr, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                                        current_pcb->remaining_time, current_pcb->waiting_time, TA, WTA);\n                printf(RED \"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\" RESET,\n                       curr, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                       current_pcb->waiting_time, TA, WTA);\n                p_count--;\n                circular_deQueue(&RRqueue); // auto advance the queue\n                buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                \n                hashmap_delete(process_table, current_pcb);\n                process_is_currently_running = false;\n                process_has_finished = true;\n\n                // if its multiple of q finished and there are some other in the Q waiting\n            }\n            else if ((curr - curr_q_start) && (curr - curr_q_start) % quantum == 0 &&\n                     !circular_is_empty_or_one_left(&RRqueue))\n            {\n\n                current_pcb->remaining_time -= curr - curr_q_start;\n                kill(current_pcb->pid, SIGSTOP);\n                current_pcb->cum_runtime += curr - curr_q_start;\n                current_pcb->waiting_time = curr - current_pcb->arrival_time - current_pcb->cum_runtime;\n                fprintf(sch_log, \"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", curr,\n                        current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                        current_pcb->waiting_time);\n                printf(\"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", curr, current_pcb->id,\n                       current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time, current_pcb->waiting_time);\n\n                current_pcb->state = READY; // back to Ready state\n                circular_advance_queue(&RRqueue);\n                process_is_currently_running = false;\n            }\n        }\n\n        while (!isEmptyQueue(&waiting_queue) && (process_has_finished || can_insert))\n        {\n            int id = front(&waiting_queue);\n            PCB *_pcb = hashmap_get(process_table, &(PCB){.id = id});\n            pair_t ret;\n            can_insert = buddy_allocate(_pcb->mem_size, &ret);\n            if (can_insert)\n            {\n                popQueue(&waiting_queue);\n                _pcb->state = READY; // allocated and in ready Queue\n                _pcb->memory_start_ind = ret.start_ind;\n                _pcb->memory_end_ind = ret.end_ind;\n                circular_enQueue(&RRqueue, id);\n                printf(CYN \"At time %d allocated %d bytes for process %d from %d to %d\\n\" RESET, curr, _pcb->mem_size,\n                       id, ret.start_ind, ret.end_ind);\n            }\n            else\n                break;\n        }\n\n        if (!process_is_currently_running && !circular_is_empty(&RRqueue))\n        {\n            // update the current_pcb as the queue is advanced\n            current_pcb = hashmap_get(process_table, &(PCB){.id = RRqueue.front->data});\n            if (current_pcb->pid == 0)\n            { // if current process never started before\n                *shm_remain_time = current_pcb->remaining_time;\n                int pid = fork();\n                if (pid == 0)\n                {\n                    // child\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n\n                // parent\n                current_pcb->pid = pid; // update Pid of existing process\n\n                current_pcb->waiting_time = curr - current_pcb->arrival_time;\n                fprintf(sch_log, \"At time %d process %d started arr %d total %d remain %d wait %d\\n\", curr,\n                        current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                        current_pcb->waiting_time);\n\n                printf(\"At time %d process %d started arr %d total %d remain %d wait %d\\n\", curr, current_pcb->id,\n                       current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time, current_pcb->waiting_time);\n            }\n            else\n            {\n\n                kill(current_pcb->pid, SIGCONT);\n                current_pcb->waiting_time = curr - current_pcb->arrival_time - current_pcb->cum_runtime;\n                *shm_remain_time = current_pcb->remaining_time;\n                fprintf(sch_log, \"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\", curr,\n                        current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,\n                        current_pcb->waiting_time);\n\n                printf(\"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\", curr, current_pcb->id,\n                       current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time, current_pcb->waiting_time);\n            }\n            current_pcb->state = RUNNING;\n            process_is_currently_running = true;\n            curr_q_start = curr; // started a quantum\n        }\n\n        // if the current's quantum finished and only one left -> no switch\n        // if the current terminated and no other in the Queue -> no switching\n    }\n    printf(\"\\nOut at time %d\\n\", getClk());\n}\n\n/**----------------------------------------------------------------\n * @Author: Ahmed Hany @Ahmed-H300\n * @param : void ()\n * @return: void\n */\n//----------------------------------------------------------------\nvoid SRTN()\n{\n    printf(\"Entering SRTN \\n\");\n    // intialize the priority queue\n    minHeap sQueue;\n    sQueue = init_min_heap();\n\n    queue waiting_queue = initQueue(); // to receive in it\n\n    PCB *current_pcb = NULL;\n    int p_count = TotalNumberOfProcesses;\n    int need_to_receive = TotalNumberOfProcesses;\n    bool process_is_currently_running = false;\n    bool can_insert = true;\n\n    // if the Queue is empty then check if there is no more processes that will come\n    // the main loop for the scheduler\n    while (!is_empty(&sQueue) || p_count > 0)\n    {\n        // First check if any process has come\n        count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        int current_time = getClk();\n        int num_messages = c.count;\n        need_to_receive -= c.count;\n        while (num_messages > 0)\n        {\n            // while still a process in the queue\n            // take it out\n            // add it to both the Prority Queue (sQueue) and its PCB to the processTable\n            process_struct coming_process;\n\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 1,\n                   !IPC_NOWAIT);\n            printf(\"\\nrecv process with id: %d at time %d with priority %d\\n\", coming_process.id, current_time,\n                   coming_process.priority);\n\n            //  you have that struct Now\n            PCB pcb;\n            pcb.id = coming_process.id;\n            pcb.pid = 0;\n            // pcb.arrival_time = coming_process.arrival;\n            pcb.arrival_time = current_time;\n            pcb.priority = coming_process.priority;\n            pcb.state = READY;\n            pcb.cum_runtime = 0;\n            pcb.burst_time = coming_process.runtime;     // at the beginning\n            pcb.remaining_time = coming_process.runtime; // at the beginning\n            pcb.waiting_time = 0;\n            pcb.mem_size = coming_process.mem_size;                           // at the beginning\n            hashmap_set(process_table, &pcb);             // this copies the content of the struct\n            pushQueue(&waiting_queue, coming_process.id); // add to the waiting list and will see if you can Run\n\n            // push(&sQueue, pcb.remaining_time, pcb.id);   // add this process to the end of the Queue\n            // heapify(&sQueue, 0);\n            num_messages--;\n        }\n\n        bool process_has_finished = false;\n        if (current_pcb != NULL)\n        {\n            //*shm_remain_time -= (current_time -(current_pcb->arrival_time + current_pcb->cum_runtime + current_pcb->waiting_time));\n            current_pcb->remaining_time -= (current_time - (current_pcb->arrival_time + current_pcb->cum_runtime + current_pcb->waiting_time));\n            // if(current_pcb->id == 3){\n            //     printf(\"remaining time %d %d\\n\",current_time,current_pcb->waiting_time);\n            // }\n            // if(current_time == 20 || current_time == 21 || current_time ==22 || current_time == 23 || current_time == 24)\n            // {\n            //     printf(\"time %d  id %d remaining time -- waiting %d %d\\n\",current_time,current_pcb->id, *shm_remain_time, current_pcb->waiting_time);\n            // }\n            //current_pcb->remaining_time = *shm_remain_time;\n            current_pcb->cum_runtime = current_pcb->burst_time - current_pcb->remaining_time;\n            //\n            if (current_pcb->remaining_time <= 0)\n            {\n                //*shm_remain_time = 0;\n                current_pcb->remaining_time = 0;\n                current_pcb->cum_runtime = current_pcb->burst_time;\n                // kill and out new data\n                int dum;\n                int ret = wait(&dum);\n                int TA = current_time - current_pcb->arrival_time;\n                float WTA = (float)TA / current_pcb->burst_time;\n                printf(\"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\",\n                       current_time, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                       *shm_remain_time, current_pcb->waiting_time, TA, WTA);\n                \n                OutputFinishedProcesses(current_time, current_pcb->id, current_pcb->arrival_time,\n                                        current_pcb->burst_time, *shm_remain_time, current_pcb->waiting_time, TA, WTA);\n                hashmap_delete(process_table, current_pcb);\n                buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                p_count--;\n                current_pcb = NULL;\n                process_has_finished = true;\n            }\n        }\n        // 3 cases\n        // first is first start process or there is gap between processes -> Done\n        // second update the remaining time\n        // third is a new process with shortest time came\n        if (!is_empty(&sQueue) && current_pcb != NULL)\n        {\n            node *temp = peek(&sQueue);\n            if (temp != NULL)\n            {\n                if (temp->priority < current_pcb->remaining_time)\n                {\n                    // swap and stop current process\n                    kill(current_pcb->pid, SIGSTOP);\n                    printf(\"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", current_time,\n                           current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                           current_pcb->remaining_time, current_pcb->waiting_time);\n                    fprintf(sch_log, \"At time %d process %d stopped arr %d total %d remain %d wait %d\\n\", current_time,\n                            current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                            current_pcb->remaining_time, current_pcb->waiting_time);\n\n                    current_pcb->state = READY; // back to Ready state\n                    push(&sQueue, current_pcb->remaining_time,\n                         current_pcb->id); // add this process to the end of the Queue\n                    heapify(&sQueue, 0);\n\n                    current_pcb = NULL;\n                }\n            }\n        }\n        while (!isEmptyQueue(&waiting_queue) && (process_has_finished || can_insert))\n        {\n            int id = front(&waiting_queue);\n            PCB *_pcb = hashmap_get(process_table, &(PCB){.id = id});\n            pair_t ret;\n            can_insert = buddy_allocate(_pcb->mem_size, &ret);\n            if (can_insert)\n            {\n                popQueue(&waiting_queue);\n                _pcb->state = READY; // allocated and in ready Queue\n                _pcb->memory_start_ind = ret.start_ind;\n                _pcb->memory_end_ind = ret.end_ind;\n                //circular_enQueue(&RRqueue, id);\n                push(&sQueue, _pcb->remaining_time, _pcb->id); // add this process to the end of the Queue\n                heapify(&sQueue, 0);\n                printf(CYN \"At time %d allocated %d bytes for process %d from %d to %d\\n\" RESET, current_time, _pcb->mem_size,\n                       id, ret.start_ind, ret.end_ind);\n            }\n            else\n                break;\n        }\n        if (current_pcb == NULL && !is_empty(&sQueue))\n        {\n            node *temp = pop(&sQueue);\n            heapify(&sQueue, 0);\n            PCB get_process = {.id = temp->data};\n            current_pcb = hashmap_get(process_table, &get_process);\n            *shm_remain_time = current_pcb->remaining_time;\n            //  first time\n            if (current_pcb->pid == 0)\n            {\n                int pid = fork();\n                if (pid == 0)\n                {\n                    // child\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n\n                // continue scheduler\n                // int curr = current_time;\n                current_pcb->pid = pid; // update Pid of existing process\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_time - current_pcb->arrival_time;\n                printf(\"At time %d process %d started arr %d total %d remain %d wait %d\\n\",\n                       current_time, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                       *shm_remain_time, current_pcb->waiting_time);\n              \n                fprintf(sch_log,\"At time %d process %d started arr %d total %d remain %d wait %d\\n\",\n                       current_time, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                       *shm_remain_time, current_pcb->waiting_time);\n            }\n            // resumed after stopped\n            else\n            {\n                kill(current_pcb->pid, SIGCONT);\n\n                // continue scheduler\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_time - (current_pcb->arrival_time + current_pcb->cum_runtime);\n                // if(current_pcb->id == 3){\n                //     printf(\"current %d arrivl %d -- cum %d -- waiting time %d\\n\", current_time, current_pcb->arrival_time, current_pcb->cum_runtime, current_pcb->waiting_time);\n                // }\n                printf(\"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\",\n                       current_time, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                       *shm_remain_time, current_pcb->waiting_time);\n              \n                fprintf(sch_log, \"At time %d process %d resumed arr %d total %d remain %d wait %d\\n\",\n                        current_time, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                        *shm_remain_time, current_pcb->waiting_time);\n            }\n        }\n    }\n    printf(\"\\nOut at time %d\\n\", getClk());\n}\n\nvoid HPF()\n{\n    minHeap hpf_queue = init_min_heap();\n\n    pcb_s *current_pcb;\n    bool process_is_currently_running = false;\n    int started_clk, current_clk;\n    int need_to_receive = TotalNumberOfProcesses;\n\n    int p_count = TotalNumberOfProcesses;\n\n    while (!is_empty(&hpf_queue) || p_count > 0 || process_is_currently_running)\n    {\n\n        struct count_msg c = {.count = 0};\n        if (more_processes_coming || need_to_receive > 0)\n            msgrcv(process_msg_queue, &c, sizeof(int), 10, !IPC_NOWAIT);\n\n        current_clk = getClk();\n        int num_messages = c.count;\n        while (num_messages > 0) {\n            // while still a process in the queue\n            // take it out\n            // add it to both the hpf_queue and its PCB to the processTable\n            struct process_struct coming_process;\n            msgrcv(process_msg_queue, &coming_process, sizeof(coming_process) - sizeof(coming_process.mtype), 0,\n                   !IPC_NOWAIT);\n            // you have that struct Now\n            struct PCB pcb;\n            pcb.id = coming_process.id;\n            pcb.pid = 0;\n            pcb.priority = coming_process.priority;\n            pcb.arrival_time = coming_process.arrival;\n            pcb.cum_runtime = 0;\n            pcb.remaining_time = coming_process.runtime; // at the beginning\n            pcb.burst_time = coming_process.runtime;\n            pcb.state = READY;\n            pcb.mem_size =  300;\n            hashmap_set(process_table, &pcb);                             // this copies the content of the struct\n            push(&hpf_queue, coming_process.priority, coming_process.id); // add this process to the priority queue\n            printf(\"Received process with priority %d and id %d at time %d \\n\", coming_process.priority,\n                   coming_process.id, getClk());\n            // printf(\"Front of the queue is %d\\n\", peek(&hpf_queue)->priority);\n            num_messages--;\n        }\n        if (!is_empty(&hpf_queue) || process_is_currently_running)\n        {\n            if (process_is_currently_running)\n            {\n\n\n                if (current_clk - started_clk == current_pcb->remaining_time)\n                {\n                    int st;\n                    // (*shm_remain_time) = 0;\n                    int ret = wait(&st);\n                    int TA = current_clk - current_pcb->arrival_time;\n                    current_pcb->remaining_time =0;\n                    current_pcb->waiting_time = TA - current_pcb->burst_time;\n                    float WTA = (float)TA / current_pcb->burst_time;\n                    p_count--;\n                    buddy_deallocate(current_pcb->memory_start_ind, current_pcb->memory_end_ind);\n                    printf(\"At time %d freed %d byted for process %d from %d to %d\\n\",\n                       current_clk, current_pcb->mem_size,current_pcb->id,current_pcb->memory_start_ind,current_pcb->memory_end_ind);\n                    printf(\"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\",\n                           current_clk, current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time,\n                           current_pcb->remaining_time, current_pcb->waiting_time, TA, WTA);\n                    OutputFinishedProcesses(current_clk, current_pcb->id, current_pcb->arrival_time,\n                                            current_pcb->burst_time, current_pcb->remaining_time, current_pcb->waiting_time, TA,\n                                            WTA);\n                    hashmap_delete(process_table, current_pcb);\n                    process_is_currently_running = false;\n                }\n            }\n            if (!process_is_currently_running && !is_empty(&hpf_queue))\n            {\n                pcb_s get_process = {.id = peek(&hpf_queue)->data};\n                current_pcb = hashmap_get(process_table, &get_process);\n\n                (*shm_remain_time) = current_pcb->remaining_time;\n\n                int pid = fork();\n                if (pid == 0)\n                {\n                    // child\n                    // printf(\"Create process: %d with priority: %d\\n\", peek(&hpf_queue)->data, peek(&hpf_queue)->priority);\n                    execl(\"./process.out\", \"./process.out\", NULL);\n                }\n                pair_t ret; \n                buddy_allocate(current_pcb->mem_size, &ret);\n                started_clk = current_clk;\n                process_is_currently_running = true;\n                // parent take the pid to the hashmap\n                current_pcb->pid = pid; // update Pid of existing process\n                current_pcb->state = RUNNING;\n                current_pcb->waiting_time = current_clk - current_pcb->arrival_time;\n                current_pcb->memory_start_ind = ret.start_ind;\n                current_pcb->memory_end_ind = ret.end_ind;\n                // circular_enQueue(&RRqueue, id);\n                printf(CYN \"At time %d allocated %d bytes for process %d from %d to %d\\n\" RESET, current_clk, current_pcb->mem_size,\n                       current_pcb->id, ret.start_ind, ret.end_ind);\n\n                printf(\"At time %d process %d started arr %d total %d remain %d wait %d\\n\", current_clk,\n                       current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,//*shm_remain_time,\n                       current_pcb->waiting_time);\n                fprintf(sch_log, \"At time %d process %d started arr %d total %d remain %d wait %d\\n\", current_clk,\n                        current_pcb->id, current_pcb->arrival_time, current_pcb->burst_time, current_pcb->remaining_time,//*shm_remain_time,\n                        current_pcb->waiting_time);\n                pop(&hpf_queue);\n            }\n        }\n    }\n}\n\nvoid scheduler_log()\n{\n    sch_log = fopen(\"scheduler.log\", \"w\");\n    if (sch_log == NULL)\n    {\n        printf(\"error has been occured while creation or opening scheduler.log\\n\");\n    }\n    else\n    {\n        fprintf(sch_log, \"#At time x process y state arr w total z remain y wait k\\n\");\n    }\n}\n\nvoid memory_log() {\n    mem_log = fopen(\"memory.log\", \"w\");\n    if (mem_log == NULL) {\n        printf(\"error has been occured while creation or opening memory.log\\n\");\n    } else {\n        fprintf(mem_log, \"#At time x allocated y bytes for processz from i to j\\n\");\n    }\n}\n\nvoid scheduler_perf(int ProcessesCount) {\n    sch_perf = fopen(\"scheduler.perf\", \"w\");\n    if (sch_perf == NULL)\n    {\n        printf(\"error has been occured while creation or opening scheduler.perf\\n\");\n    }\n    else\n    {\n        float CPU_Utilization = ((float)TotalRunTime / getClk()) * 100;\n        fprintf(sch_perf, \"CPU utilization = %.2f %%\\n\", CPU_Utilization);\n        fprintf(sch_perf, \"Avg WTA = %.2f\\n\", ((float)TotalWTA) / ProcessesCount);\n        fprintf(sch_perf, \"Avg Waiting = %.2f\\n\", ((float)TotalWaitingTime) / ProcessesCount);\n        fprintf(sch_perf, \"Std WTA = %.2f\\n\", CalcStdWTA(((float)TotalWTA) / ProcessesCount));\n    }\n}\n\nvoid OutputFinishedProcesses(int CurrTime, int ID, int ArrTime, int RunningTime, int RemainTime, int WaitingTime, int TA,\n                             float WTA)\n{\n    // printing in a file\n    fprintf(sch_log, \"At time %d process %d finished arr %d total %d remain %d wait %d TA %d WTA %.2f\\n\", CurrTime, ID,\n            ArrTime, RunningTime, RemainTime, WaitingTime, TA, WTA);\n\n    // update stats variables\n    TotalRunTime += RunningTime;\n    TotalWTA += WTA;\n    TotalWaitingTime += WaitingTime;\n    WeightedTA[WTAIterator] = WTA;\n    WTAIterator++;\n}\n\nfloat CalcStdWTA(float AvgWTA)\n{\n    float numerator = 0;\n    float Variance = 0;\n    for (int i = 0; i < TotalNumberOfProcesses; i++)\n    {\n        numerator += pow((WeightedTA[i] - AvgWTA), 2);\n    }\n    Variance = numerator / TotalNumberOfProcesses;\n    return sqrt(Variance);\n}\n\nvoid FinishPrinting()\n{\n    fclose(sch_log);\n    fclose(sch_perf);\n    fclose(mem_log);\n    free(WeightedTA);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.c b/scheduler.c
--- a/scheduler.c	(revision 6dc585cd9c88bae4ff81e79d89424b3e43705ad4)
+++ b/scheduler.c	(date 1653583737968)
@@ -396,7 +396,7 @@
             pcb.burst_time = coming_process.runtime;     // at the beginning
             pcb.remaining_time = coming_process.runtime; // at the beginning
             pcb.waiting_time = 0;
-            pcb.mem_size = coming_process.mem_size;                           // at the beginning
+            pcb.mem_size = coming_process.memsize;                           // at the beginning
             hashmap_set(process_table, &pcb);             // this copies the content of the struct
             pushQueue(&waiting_queue, coming_process.id); // add to the waiting list and will see if you can Run
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"CMakeRunConfigurationManager\">\n    <generated />\n  </component>\n  <component name=\"CMakeSettings\">\n    <configurations>\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\n    </configurations>\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"eb74cbae-2b8d-4ad0-b305-4f35558e8945\" name=\"Changes\" comment=\" changing Remaining Time\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.vscode/targets.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.vscode/targets.log\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Makefile\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Makefile\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/process_generator.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/process_generator.c\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/processes.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/processes.txt\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/scheduler.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/scheduler.c\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/scheduler.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/scheduler.log\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/scheduler.perf\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/scheduler.perf\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/test_generator.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test_generator.c\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ClangdSettings\">\n    <option name=\"formatViaClangd\" value=\"false\" />\n  </component>\n  <component name=\"ExternalProjectsData\">\n    <projectState path=\"$PROJECT_DIR$\">\n      <ProjectState />\n    </projectState>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$/../..\" value=\"atta\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/../..\" />\n  </component>\n  <component name=\"MakefileLocalSettings\">\n    <option name=\"availableProjects\">\n      <map>\n        <entry>\n          <key>\n            <ExternalProjectPojo>\n              <option name=\"name\" value=\"code\" />\n              <option name=\"path\" value=\"$PROJECT_DIR$\" />\n            </ExternalProjectPojo>\n          </key>\n          <value>\n            <list>\n              <ExternalProjectPojo>\n                <option name=\"name\" value=\"code\" />\n                <option name=\"path\" value=\"$PROJECT_DIR$\" />\n              </ExternalProjectPojo>\n            </list>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"projectSyncType\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"RE_IMPORT\" />\n      </map>\n    </option>\n  </component>\n  <component name=\"MakefilesProjectLoadingState\">\n    <option name=\"doClean\" value=\"false\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectApplicationVersion\">\n    <option name=\"ide\" value=\"CLion\" />\n    <option name=\"majorVersion\" value=\"2022\" />\n    <option name=\"minorVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"28iaeKe0W5RiQB3GpPOuj0kNKuE\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Git.Branch.Popup.ShowAllRemotes\": \"true\",\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"RunOnceActivity.cidr.known.project.marker\": \"true\",\n    \"WebServerToolWindowFactoryState\": \"false\",\n    \"cf.first.check.clang-format\": \"false\",\n    \"cidr.known.project.marker\": \"true\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"settings.editor.selected.configurable\": \"preferences.lookFeel\",\n    \"structure.view.defaults.are.configured\": \"true\"\n  }\n}]]></component>\n  <component name=\"RunManager\">\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\n      <method v=\"2\">\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\n      </method>\n    </configuration>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"eb74cbae-2b8d-4ad0-b305-4f35558e8945\" name=\"Changes\" comment=\"\" />\n      <created>1651701954964</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1651701954964</updated>\n      <workItem from=\"1651701956794\" duration=\"2891000\" />\n      <workItem from=\"1651741541771\" duration=\"7000\" />\n      <workItem from=\"1651741795977\" duration=\"8000\" />\n      <workItem from=\"1651741912093\" duration=\"1001000\" />\n      <workItem from=\"1651746733229\" duration=\"3286000\" />\n      <workItem from=\"1651833951326\" duration=\"8093000\" />\n      <workItem from=\"1651950945153\" duration=\"1337000\" />\n      <workItem from=\"1652560242591\" duration=\"1000\" />\n      <workItem from=\"1652563360727\" duration=\"6374000\" />\n      <workItem from=\"1652953668020\" duration=\"793000\" />\n      <workItem from=\"1652956405104\" duration=\"7000\" />\n      <workItem from=\"1653582405007\" duration=\"1117000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"new phase\">\n      <created>1651702962617</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651702962617</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"before main changes\">\n      <created>1651747442807</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651747442807</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"started buddy\">\n      <created>1651750011140</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651750011140</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"initial tests buddy\">\n      <created>1651839280574</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651839280574</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"some tests and passed\">\n      <created>1651839929289</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651839929289</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"more tests passed\">\n      <created>1651842015623</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1651842015623</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"more tests passed\">\n      <created>1652563393266</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563393266</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"returned to correct version\">\n      <created>1652563882138</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563882138</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"returned to correct version\">\n      <created>1652563891556</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652563891556</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"Before changing Remaing Time\">\n      <created>1652566926737</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652566926737</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\" changing Remaining Time\">\n      <created>1652569218486</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1652569218486</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"12\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"new phase\" />\n    <MESSAGE value=\"before main changes\" />\n    <MESSAGE value=\"started buddy\" />\n    <MESSAGE value=\"initial tests buddy\" />\n    <MESSAGE value=\"some tests and passed\" />\n    <MESSAGE value=\"more tests passed\" />\n    <MESSAGE value=\"returned to correct version\" />\n    <MESSAGE value=\"Before changing Remaing Time\" />\n    <MESSAGE value=\" changing Remaining Time\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\" changing Remaining Time\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 6dc585cd9c88bae4ff81e79d89424b3e43705ad4)
+++ b/.idea/workspace.xml	(date 1653583832390)
@@ -12,16 +12,10 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="eb74cbae-2b8d-4ad0-b305-4f35558e8945" name="Changes" comment=" changing Remaining Time">
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.vscode/targets.log" beforeDir="false" afterPath="$PROJECT_DIR$/.vscode/targets.log" afterDir="false" />
+    <list default="true" id="eb74cbae-2b8d-4ad0-b305-4f35558e8945" name="Changes" comment="merged hany">
       <change beforePath="$PROJECT_DIR$/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/Makefile" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/process_generator.c" beforeDir="false" afterPath="$PROJECT_DIR$/process_generator.c" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/processes.txt" beforeDir="false" afterPath="$PROJECT_DIR$/processes.txt" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/scheduler.c" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.c" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/scheduler.log" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.log" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/scheduler.perf" beforeDir="false" afterPath="$PROJECT_DIR$/scheduler.perf" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test_generator.c" beforeDir="false" afterPath="$PROJECT_DIR$/test_generator.c" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -128,7 +122,7 @@
       <workItem from="1652563360727" duration="6374000" />
       <workItem from="1652953668020" duration="793000" />
       <workItem from="1652956405104" duration="7000" />
-      <workItem from="1653582405007" duration="1117000" />
+      <workItem from="1653582405007" duration="1427000" />
     </task>
     <task id="LOCAL-00001" summary="new phase">
       <created>1651702962617</created>
@@ -207,7 +201,14 @@
       <option name="project" value="LOCAL" />
       <updated>1652569218486</updated>
     </task>
-    <option name="localTasksCounter" value="12" />
+    <task id="LOCAL-00012" summary="merged hany">
+      <created>1653583576539</created>
+      <option name="number" value="00012" />
+      <option name="presentableId" value="LOCAL-00012" />
+      <option name="project" value="LOCAL" />
+      <updated>1653583576539</updated>
+    </task>
+    <option name="localTasksCounter" value="13" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -234,6 +235,7 @@
     <MESSAGE value="returned to correct version" />
     <MESSAGE value="Before changing Remaing Time" />
     <MESSAGE value=" changing Remaining Time" />
-    <option name="LAST_COMMIT_MESSAGE" value=" changing Remaining Time" />
+    <MESSAGE value="merged hany" />
+    <option name="LAST_COMMIT_MESSAGE" value="merged hany" />
   </component>
 </project>
\ No newline at end of file
Index: scheduler.perf
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>CPU utilization = 96.10 %\nAvg WTA = 2.00\nAvg Waiting = 19.00\nStd WTA = 0.71\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scheduler.perf b/scheduler.perf
--- a/scheduler.perf	(revision 6dc585cd9c88bae4ff81e79d89424b3e43705ad4)
+++ b/scheduler.perf	(date 1653583816165)
@@ -1,4 +1,4 @@
 CPU utilization = 96.10 %
-Avg WTA = 2.00
-Avg Waiting = 19.00
-Std WTA = 0.71
+Avg WTA = 1.25
+Avg Waiting = 10.00
+Std WTA = 0.43
